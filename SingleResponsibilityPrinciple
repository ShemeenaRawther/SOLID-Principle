SOLID Principles - Single Responsibility Principle (SRP) in C#
ğŸ“Œ What is SRP?
The Single Responsibility Principle (SRP) states that a class should have only one responsibility.
Each class should focus on one responsibility, which enhances reusability and readability.

ğŸ”§ Problem Statement
ğŸ“Œ Requirement:
We need to:
1ï¸âƒ£ Get employee details
2ï¸âƒ£ Calculate employee salary
3ï¸âƒ£ Save employee details to the database

ğŸ’¡ Initial Thought:
A single class handling all these responsibilities.

public class Employee
{
    public string Name { get; set; }
    public double Salary { get; set; }

    // âŒ SRP Violation: This method calculates salary
    public double CalculateSalary()
    {
        return Salary * 2.0; // Applying a bonus
    }

    // âŒ SRP Violation: This method saves employee data to the database
    public void SaveEmployeeDetails()
    {
        Console.WriteLine("Employee saved to database.");
    }
}
ğŸ”´ Issues in this Code:
âŒ Mixed Responsibilities: The class handles too many things (data, business logic, and database operations).
âŒ Hard to Maintain: If the salary calculation logic changes, we have to modify a class that also handles database logic.
âŒ Difficult to Test: Unit testing is harder because the class has multiple concerns.

âœ… Refactored Code - Following SRP
Step 1ï¸âƒ£: Create an Employee Model (Only Holds Data)
public class Employee
{
    public string Name { get; set; }
    public double Salary { get; set; }
}
âœ” Now, Employee class only stores data.

Step 2ï¸âƒ£: Create a SalaryCalculator Class
Handles only salary-related logic.
public class SalaryCalculator
{
    public double Calculate(Employee employee)
    {
        return employee.Salary * 2.0; // Applying a 20% bonus
    }
}
âœ” Now, Salary calculation is in a separate class.

Step 3ï¸âƒ£: Create an EmployeeRepository Class
Handles database operations separately.
public class EmployeeRepository
{
    public void SaveToDatabase(Employee employee)
    {
        Console.WriteLine($"Employee {employee.Name} saved to database.");
    }
}
âœ” Now, the database operation is also separate.

ğŸ’¡ Final Thoughts
By separating responsibilities, we achieve:
âœ… Better Code Reusability
âœ… Easier Maintenance
âœ… Better Testability
âœ… More Readable & Clean Code

ğŸ›  Running the Code
To test the above classes in a Main Program:
class Program
{
    static void Main()
    {
        Employee emp = new Employee { Name = "John Doe", Salary = 50000 };

        // Salary calculation
        SalaryCalculator salaryCalculator = new SalaryCalculator();
        double newSalary = salaryCalculator.Calculate(emp);
        Console.WriteLine($"New Salary: {newSalary}");

        // Save employee details
        EmployeeRepository repository = new EmployeeRepository();
        repository.SaveToDatabase(emp);
    }
}
ğŸ“Œ Summary
Approach	Issues / Benefits
âŒ Bad Example (SRP Violation)	One class handles multiple responsibilities (salary calculation, database operations).
âœ… Good Example (Follows SRP)	Each class has one responsibility, making the code cleaner and more maintainable.
