Liskov Substitution Principle (LSP):
ğŸ“Œ What is the Liskov Substitution Principle (LSP)?
The Liskov Substitution Principle (LSP) states:
ğŸ”¹ "Subtypes must be substitutable for their base types without altering the correctness of the program."
ğŸ”¹ This means that if class B is a subclass of class A, we should be able to replace A with B without breaking the behavior of the application.
ğŸ”¹ It ensures correct inheritance by preventing unexpected behavior in derived classes.

ğŸ“Œ Scenario
A company supports multiple payment methods (e.g., Credit Card, PayPal, and UPI).
We need to process payments without modifying existing code when adding new payment methods.

public class PaymentProcessor
{
    public virtual void ProcessPayment(double amount)
    {
        Console.WriteLine($"Processing payment of {amount}...");
    }
}

// âŒ LSP Violation: PayPal doesn't support direct payment, but we're forcing it
public class PayPalProcessor : PaymentProcessor
{
    public override void ProcessPayment(double amount)
    {
        throw new NotImplementedException("PayPal requires authentication before processing payment.");
    }
}
ğŸ”´ Issues in this Code
âŒ LSP Violation â€“ PayPalProcessor cannot be used as a PaymentProcessor.
âŒ Unexpected Behavior â€“ Instead of processing payment, PayPalProcessor throws an exception.
âŒ Breaks Substitution Rule â€“ If we replace PaymentProcessor with PayPalProcessor, it fails unexpectedly.

how to fix this :
Instead of forcing incorrect inheritance, we use an interface to define payment behavior.
Step 1ï¸âƒ£: Define a Payment Interface
public interface IPayment
{
    void ProcessPayment(double amount);
}
âœ” Now, all payment methods must implement this interface correctly
Step 2ï¸âƒ£: Implement Payment Methods Correctly
public class CreditCardPayment : IPayment
{
    public void ProcessPayment(double amount)
    {
        Console.WriteLine($"Processing Credit Card payment of {amount}");
    }
}

public class PayPalPayment : IPayment
{
    public void ProcessPayment(double amount)
    {
        Console.WriteLine($"Processing PayPal payment of {amount} after authentication.");
    }
}

public class UPIPayment : IPayment
{
    public void ProcessPayment(double amount)
    {
        Console.WriteLine($"Processing UPI payment of {amount}");
    }
}
âœ” Each payment method follows LSP correctly without overriding unwanted behaviors.
Step 3ï¸âƒ£: Use Payment Methods Without Breaking LSP

class PaymentService
{
    public static void MakePayment(IPayment paymentMethod, double amount)
    {
        paymentMethod.ProcessPayment(amount);
    }

    static void Main()
    {
        IPayment creditCard = new CreditCardPayment();
        IPayment payPal = new PayPalPayment();
        IPayment upi = new UPIPayment();

        MakePayment(creditCard, 500.00);  // âœ… Works
        MakePayment(payPal, 300.00);      // âœ… Works
        MakePayment(upi, 200.00);         // âœ… Works
    }
}

âœ” Now, we can add new payment methods without modifying existing code.
âœ” Each payment method can be substituted without breaking behavior (LSP).
âœ… Benefits of Following LSP
Bad Example (LSP Violation)	Good Example (Follows LSP)
âŒ PayPalProcessor breaks expected behavior.	âœ… PayPalPayment implements payment logic correctly.
âŒ Substituting PaymentProcessor with PayPalProcessor fails.	âœ… All payment methods work interchangeably via IPayment.
âŒ Forces incorrect inheritance.	âœ… Uses interfaces for correct polymorphism.

ğŸ¯ Summary
ğŸ”¹ LSP Rule: A derived class should be able to replace its base class without breaking functionality.
ğŸ”¹ Use interfaces instead of forcing inheritance when behavior varies.
ğŸ”¹ Ensures flexibility â€“ We can add new payment methods without modifying existing code.
