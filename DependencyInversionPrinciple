Dependency Inversion Principle (DIP):
üìå What is the Dependency Inversion Principle (DIP)?
üîπ "High-level modules should not depend on low-level modules. Both should depend on abstractions."
üîπ "Abstractions should not depend on details. Details should depend on abstractions."
üîπ This helps in making the system loosely coupled, more maintainable, and easier to extend.

üìå Requirement
Scenario:
A company wants to design a notification system that supports:
‚úÖ Email Notifications
‚úÖ SMS Notifications

The system should be flexible so that new notification types (e.g., Push Notifications) can be added without modifying existing code.
lets implement the above requirment normally and identify the issue with it.
// ‚ùå Low-level module: Directly tied to a specific implementation
public class EmailNotification
{
    public void SendEmail(string message)
    {
        Console.WriteLine("Sending Email: " + message);
    }
}

public class SMSNotification
{
    public void SendSMS(string message)
    {
        Console.WriteLine("Sending SMS: " + message);
    }
}

// ‚ùå High-level module directly depends on low-level modules
public class NotificationService
{
    private EmailNotification emailNotification;
    private SMSNotification smsNotification;

    public NotificationService()
    {
        emailNotification = new EmailNotification();
        smsNotification = new SMSNotification();
    }

    public void SendNotification(string message)
    {
        emailNotification.SendEmail(message);
        smsNotification.SendSMS(message);
    }
}

üî¥ Issues in this Code
‚ùå Violates DIP ‚Äì NotificationService depends on specific classes (EmailNotification, SMSNotification).
‚ùå Hard to Extend ‚Äì Adding Push Notifications requires modifying NotificationService.
‚ùå Tightly Coupled ‚Äì Cannot easily replace or modify notification methods.

To fix this issue, we introduce an abstraction (INotification) so that NotificationService depends on an interface, not a concrete class.
Step 1Ô∏è‚É£: Create an Abstraction for Notifications
// ‚úÖ Abstraction: High-level module depends on this, not on concrete classes
public interface INotification
{
    void Send(string message);
}
‚úî Now, notifications are loosely coupled from the service.
Step 2Ô∏è‚É£: Implement Concrete Notification Methods
// ‚úÖ Low-level module implements the abstraction
public class EmailNotification : INotification
{
    public void Send(string message)
    {
        Console.WriteLine("Sending Email: " + message);
    }
}

public class SMSNotification : INotification
{
    public void Send(string message)
    {
        Console.WriteLine("Sending SMS: " + message);
    }
}

// ‚úÖ We can add new types without modifying the NotificationService
public class PushNotification : INotification
{
    public void Send(string message)
    {
        Console.WriteLine("Sending Push Notification: " + message);
    }
}
‚úî Now, NotificationService does not need to change if we add PushNotification.
Step 3Ô∏è‚É£: Modify NotificationService to Depend on Abstraction
// ‚úÖ High-level module depends on abstraction (INotification), not concrete classes
public class NotificationService
{
    private readonly INotification _notification;

    public NotificationService(INotification notification)
    {
        _notification = notification;
    }

    public void SendNotification(string message)
    {
        _notification.Send(message);
    }
}
‚úî Now, NotificationService works with any notification type.

Step 4Ô∏è‚É£: Use Dependency Injection to Pass Notification Type
class Program
{
    static void Main()
    {
        // ‚úÖ We can switch notification methods without modifying NotificationService
        INotification email = new EmailNotification();
        INotification sms = new SMSNotification();
        INotification push = new PushNotification();

        NotificationService emailService = new NotificationService(email);
        emailService.SendNotification("Welcome Email!");

        NotificationService smsService = new NotificationService(sms);
        smsService.SendNotification("Your OTP is 123456");

        NotificationService pushService = new NotificationService(push);
        pushService.SendNotification("New offer available!");
    }
}

‚úî Now, we can change the notification type without modifying NotificationService.
‚úî We follow DIP by depending on abstractions (INotification), not concrete classes.

‚úÖ Benefits of Following DIP
Bad Example (DIP Violation)	Good Example (Follows DIP)
‚ùå High-level module (NotificationService) depends on concrete classes.	‚úÖ High-level module depends on an interface (INotification).
‚ùå Hard to extend ‚Äì Adding new notifications requires modifying NotificationService.	‚úÖ Easily extendable ‚Äì Add new notifications without modifying existing code.
‚ùå Tightly coupled ‚Äì Changing one class affects others.	‚úÖ Loosely coupled ‚Äì Classes are independent.
üéØ Summary
üîπ DIP Rule: High-level modules should not depend on low-level modules. Both should depend on abstractions.
üîπ Use interfaces to decouple classes and improve maintainability.
üîπ Follow Dependency Injection to manage dependencies efficiently.
