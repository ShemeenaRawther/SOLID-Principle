ğŸ“Œ What is the Interface Segregation Principle (ISP)?
ğŸ”¹ "Clients should not be forced to depend on interfaces they do not use."
ğŸ”¹ Instead of having one large interface, split it into multiple smaller, specific interfaces.
ğŸ”¹ This prevents unnecessary dependencies in classes and ensures better maintainability.

ğŸ“Œ Requirement
Scenario:
A company wants to design a multifunctional printer system that supports:
âœ… Printing
âœ… Scanning
âœ… Faxing

However, not all printers support all functionalities.

Some printers only print.
Some printers print & scan but do not fax.
Some printers support all three functions.
We need a flexible design that allows defining only the required functionalities without forcing unnecessary dependencies.

lets implement without ISP:
// âŒ Bad: One large interface that forces all printers to implement unnecessary methods
public interface IPrinter
{
    void Print(string content);
    void Scan(string content);
    void Fax(string content);
}

// âŒ Violates ISP: Basic printers should not be forced to implement Scan and Fax
public class BasicPrinter : IPrinter
{
    public void Print(string content)
    {
        Console.WriteLine("Printing: " + content);
    }

    public void Scan(string content)
    {
        throw new NotImplementedException("BasicPrinter does not support scanning.");
    }

    public void Fax(string content)
    {
        throw new NotImplementedException("BasicPrinter does not support faxing.");
    }
}

ğŸ”´ Issues in this Code
âŒ Forces Unnecessary Implementations â€“ BasicPrinter must implement Scan() and Fax() even though it doesnâ€™t support them.
âŒ Violates ISP â€“ Clients should not be forced to depend on methods they do not need.
âŒ Leads to Runtime Errors â€“ throw new NotImplementedException(); introduces unexpected failures.

To fix the issue, split the large interface into multiple smaller interfaces:
Step 1ï¸âƒ£: Create Small, Specific Interfaces
public interface IPrint
{
    void Print(string content);
}

public interface IScan
{
    void Scan(string content);
}

public interface IFax
{
    void Fax(string content);
}
âœ” Now, printers only implement what they support.

Step 2ï¸âƒ£: Implement Specific Functionalities in Printers
// âœ… Basic Printer: Only Implements IPrint
public class BasicPrinter : IPrint
{
    public void Print(string content)
    {
        Console.WriteLine("Printing: " + content);
    }
}

// âœ… MultiFunction Printer: Implements Print, Scan, and Fax
public class MultiFunctionPrinter : IPrint, IScan, IFax
{
    public void Print(string content)
    {
        Console.WriteLine("Printing: " + content);
    }

    public void Scan(string content)
    {
        Console.WriteLine("Scanning: " + content);
    }

    public void Fax(string content)
    {
        Console.WriteLine("Faxing: " + content);
    }
}

// âœ… Scanner: Only Implements IScan
public class Scanner : IScan
{
    public void Scan(string content)
    {
        Console.WriteLine("Scanning: " + content);
    }
}
âœ” Now, each printer implements only the required interfaces.
âœ” No more unnecessary dependencies!

Step 3ï¸âƒ£: Use the Printers Without Breaking ISP

class Program
{
    static void Main()
    {
        IPrint printer = new BasicPrinter();
        printer.Print("Document.pdf");

        IScan scanner = new Scanner();
        scanner.Scan("Photo.png");

        MultiFunctionPrinter multiPrinter = new MultiFunctionPrinter();
        multiPrinter.Print("Report.docx");
        multiPrinter.Scan("Receipt.jpg");
        multiPrinter.Fax("Invoice.pdf");
    }
}

âœ” Now, each device supports only the necessary features.
âœ” No unnecessary method implementations.

âœ… Benefits of Following ISP
Bad Example (ISP Violation)	Good Example (Follows ISP)
âŒ One large interface forces unnecessary implementations.	âœ… Multiple smaller interfaces keep designs clean.
âŒ Basic printers must implement Scan() and Fax().	âœ… Printers only implement what they support.
âŒ Leads to NotImplementedException.	âœ… No runtime errors due to missing methods.

ğŸ¯ Summary
ğŸ”¹ ISP Rule: Do not force a class to implement methods it does not use.
ğŸ”¹ Split large interfaces into smaller, specific ones to avoid unnecessary dependencies.
ğŸ”¹ Ensures flexibility and maintainability.
